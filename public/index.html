<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Perfect Stack</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="fallingCanvas"></canvas>
<script>
    const canvas = document.getElementById("fallingCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const gravity = 0.5;
    const objects = [];

    // Загружаем три изображения
    const images = {
        diamond: { src: "diamond.png", image: new Image() },
        emerald: { src: "emerald.png", image: new Image() },
        ruby: { src: "ruby.png", image: new Image() }
    };

    // Задаём ширину/высоту объекта (предполагается одинаковый размер для всех)
    const OBJ_WIDTH = 50;
    const OBJ_HEIGHT = 50;

    // Подгружаем все изображения
    for (let key in images) {
        images[key].image.src = images[key].src;
    }

    let masks = {};

    // Функция для создания маски пикселей
    function createMask(img, width, height) {
        const offscreen = document.createElement("canvas");
        const offCtx = offscreen.getContext("2d");
        offscreen.width = width;
        offscreen.height = height;

        offCtx.drawImage(img, 0, 0, width, height);
        const imgData = offCtx.getImageData(0, 0, width, height);

        const mask = [];
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const alpha = imgData.data[(y * width + x) * 4 + 3];
                if (alpha > 0) mask.push({ x, y });
            }
        }
        return mask;
    }

    class Gem {
        constructor(x, y, img, mask) {
            this.x = x;
            this.y = y;
            this.vy = 0;
            this.width = OBJ_WIDTH;
            this.height = OBJ_HEIGHT;
            this.mask = mask; 
            this.stable = false;  
            this.img = img; 
        }

        applyGravity() {
            this.vy += gravity;
        }

        aabbCollide(other) {
            return !(this.x + this.width <= other.x ||
                     this.x >= other.x + other.width ||
                     this.y + this.height <= other.y ||
                     this.y >= other.y + other.height);
        }

        pixelPerfectCollide(other) {
            for (let { x, y } of this.mask) {
                const globalX = (this.x | 0) + x;
                const globalY = (this.y | 0) + y;
                for (let { x: ox, y: oy } of other.mask) {
                    const otherX = (other.x | 0) + ox;
                    const otherY = (other.y | 0) + oy;
                    if (globalX === otherX && globalY === otherY) return true;
                }
            }
            return false;
        }

        checkCollisionsAt(yPos) {
            const oldY = this.y;
            this.y = yPos;
            const collides = this.checkCollisions();
            this.y = oldY;
            return collides;
        }

        checkCollisions() {
            for (const other of objects) {
                if (other === this) continue;
                if (this.aabbCollide(other)) {
                    if (this.pixelPerfectCollide(other)) {
                        return true;
                    }
                }
            }
            return false;
        }

        causesFloorCollision(yPos) {
            return yPos + this.height > canvas.height;
        }

        resolveCollisions(oldY, newY) {
            if (!this.checkCollisionsAt(newY) && !this.causesFloorCollision(newY)) {
                return newY; 
            }
            if (this.checkCollisionsAt(oldY) || this.causesFloorCollision(oldY)) {
                return oldY; 
            }

            let low = oldY;
            let high = newY;
            let finalPos = oldY;

            for (let i = 0; i < 20; i++) {
                let mid = (low + high) / 2;
                if (this.checkCollisionsAt(mid) || this.causesFloorCollision(mid)) {
                    high = mid;
                } else {
                    finalPos = mid;
                    low = mid;
                }
            }

            return Math.floor(finalPos);
        }

        update() {
            if (this.stable) return;

            const oldY = this.y;
            this.applyGravity();
            const newY = this.y + this.vy;

            const resolvedY = this.resolveCollisions(oldY, newY);
            this.y = resolvedY;

            if (this.checkCollisionsAt(this.y) || this.causesFloorCollision(this.y) || resolvedY !== newY) {
                this.y = Math.floor(this.y);
                this.vy = 0;
                this.stable = true; 
            }
        }

        draw() {
            ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
        }
    }

    function placeObject(x, y) {
        // Выбираем рандомно один из ключей
        const types = Object.keys(images); // ["diamond", "emerald", "ruby"]
        const choice = types[Math.floor(Math.random() * types.length)];

        const obj = new Gem(x, y, images[choice].image, masks[choice]);

        let attempts = 100;
        while ((obj.checkCollisions() || obj.causesFloorCollision(obj.y)) && attempts > 0) {
            obj.y -= 1;
            attempts--;
        }

        if (attempts > 0) {
            objects.push(obj);
        }
        // Если attempts == 0, значит не удалось разместить без пересечения, просто не добавляем объект.
    }

    canvas.addEventListener("click", (e) => {
        const rect = canvas.getBoundingClientRect();
        const centerX = e.clientX - rect.left;
        const centerY = e.clientY - rect.top;

        placeObject(centerX - 25, centerY - 25);
    });

    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let obj of objects) {
            obj.update();
            obj.draw();
        }
        requestAnimationFrame(animate);
    }

    // Подгрузка всех изображений и создание масок
    let imagesLoaded = 0;
    for (let key in images) {
        images[key].image.onload = () => {
            masks[key] = createMask(images[key].image, OBJ_WIDTH, OBJ_HEIGHT);
            imagesLoaded++;
            if (imagesLoaded === Object.keys(images).length) {
                // Все изображения загружены
                animate();
            }
        };
    }
</script>
</body>
</html>
